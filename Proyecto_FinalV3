import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# ==============================================================================
# 1. M√ìDULO DE CONFIGURACI√ìN Y DATOS (RF9) e INTERACCI√ìN
# ==============================================================================

# **VALORES POR DEFECTO** (Base para RF9)
DEFAULT_CONFIG = {
    # Par√°metros Base
    'GOMPERTZ_ESTRUCTURAL': {'A': 200.0, 'b': 4.0, 'k': 0.015},
    'GOMPERTZ_FOLIAR': {'A': 7.0, 'b': 5.0, 'k': 0.02},
    'T_BASE': 8.0,
    
    # Par√°metros de Estr√©s T√©rmico
    'T_OPT_MIN': 15.0,
    'T_OPT_MAX': 28.0,
    
    # Par√°metros de Suelo y P√©rdidas de Agua
    'SUELO_CC': 150.0,
    'SUELO_PMP': 50.0,
    'SUELO_INICIAL': 120.0,
    'ESCORRENTIA_FRACCION': 0.15,
    
    # Coeficientes de Cultivo (Kc) por Estadio BBCH (RF2)
    'KC_BBCH': {
        '00': 0.3, '10': 0.4, '30': 0.8, '60': 1.15, '70': 0.9, '90': 0.5
    },
    'DIAS_SIMULACION': 90
}

RANGOS_BBCH = {
    (0, 500): "10 - Emergencia",
    (501, 1200): "30 - Desarrollo",
    (1201, 2000): "60 - Floraci√≥n",
    (2001, 3000): "70 - Maduraci√≥n"
}


def validar_input_rango(prompt, default_value, min_val, max_val, unit=''):
    """Helper para validar si un input est√° dentro de un rango plausible.
       Retroalimentaci√≥n espec√≠fica (insuficiente/exagerado) sin formato especial.
    """
    while True:
        user_input = input(f"{prompt} (default: {default_value}{unit}, rango: {min_val}-{max_val}{unit}): ")
        if not user_input:
            return default_value # Usa el valor por defecto si no hay input
        
        try:
            value = float(user_input)
            if min_val <= value <= max_val:
                return value
            else:
                # <-- CAMBIO DE L√ìGICA AQU√ç: Mensaje normalizado -->
                if value < min_val:
                    print(f"‚ùå ERROR: El valor {value}{unit} es demasiado bajo/insuficiente. El m√≠nimo plausible es {min_val}{unit}.")
                elif value > max_val:
                    print(f"‚ùå ERROR: El valor {value}{unit} es exagerado/demasiado alto. El m√°ximo plausible es {max_val}{unit}.")
                # <-- FIN DEL CAMBIO -->
        except ValueError:
            print("‚ùå ERROR: Ingrese un valor num√©rico v√°lido.")

def solicitar_parametros_iniciales():
    """RF9 - Permite al usuario configurar los par√°metros clave del simulador con validaci√≥n."""
    config = DEFAULT_CONFIG.copy()
    print("\n--- üìù Configuraci√≥n Inicial del Simulador (RF9 con Validaci√≥n Mejorada) ---")
    
    # 1. Par√°metros Agron√≥micos Base
    print("\n* Par√°metros Base:")
    config['T_BASE'] = validar_input_rango(
        "Ingrese Temperatura Base para GDD", config['T_BASE'], 0.0, 15.0, '¬∞C')
    
    # 2. Par√°metros de Estr√©s T√©rmico (RF7)
    print("\n* Par√°metros de Estr√©s por Temperatura (Control de FT):")
    
    # T¬∞ √ìptima M√≠nima
    config['T_OPT_MIN'] = validar_input_rango(
        "  T¬∞ √ìptima M√≠nima", config['T_OPT_MIN'], 5.0, 25.0, '¬∞C')

    # T¬∞ √ìptima M√°xima (Debe ser mayor que la m√≠nima)
    while True:
        t_max_input = validar_input_rango(
            "  T¬∞ √ìptima M√°xima", config['T_OPT_MAX'], 20.0, 40.0, '¬∞C')
        if t_max_input > config['T_OPT_MIN']:
            config['T_OPT_MAX'] = t_max_input
            break
        else:
            print(f"‚ùå ERROR: T¬∞ M√°xima ({t_max_input}¬∞C) debe ser mayor que T¬∞ M√≠nima ({config['T_OPT_MIN']}¬∞C).")
            
    # 3. Par√°metros de Manejo de Agua (RF6/RF9)
    print("\n* Par√°metros de Suelo y Manejo de Agua:")
    config['SUELO_CC'] = validar_input_rango(
        "  Capacidad de Campo CC", config['SUELO_CC'], 50.0, 300.0, ' mm')
        
    config['SUELO_PMP'] = validar_input_rango(
        "  Punto de Marchitez Permanente PMP", config['SUELO_PMP'], 10.0, config['SUELO_CC'] * 0.9, ' mm')

    config['ESCORRENTIA_FRACCION'] = validar_input_rango(
        "  Fracci√≥n de Escorrent√≠a", config['ESCORRENTIA_FRACCION'], 0.0, 1.0, '')
    
    print("\n--- ‚úÖ Configuraci√≥n Guardada ---")
    return config

def generar_datos_met(dias_simulacion):
    """RF9. Simula datos clim√°ticos diarios, incluyendo Lluvia, Riego y ET base."""
    tmax = np.random.uniform(20, 32, dias_simulacion)
    tmin = np.random.uniform(10, 18, dias_simulacion)
    radiacion = np.random.uniform(15, 25, dias_simulacion)
    lluvia = np.array([np.random.choice([0, 0, 0, 0, 5, 10, 20]) for _ in range(dias_simulacion)])
    
    riego = np.zeros(dias_simulacion)
    riego[[30, 60, 80]] = 25 
    
    ET0_diaria = np.random.uniform(4.0, 6.0, dias_simulacion) 
    
    return pd.DataFrame({
        'Tmax': tmax, 'Tmin': tmin, 'Radiacion': radiacion, 
        'Lluvia': lluvia, 'Riego': riego, 'ET0': ET0_diaria
    })

# ==============================================================================
# 2. M√ìDULO DE MODELOS MATEM√ÅTICOS Y BIOL√ìGICOS
# ==============================================================================

def calcular_GDD_diario(Tmax, Tmin, Tbase):
    """RF1. Calcula los Grados-D√≠a diarios."""
    T_promedio = (Tmax + Tmin) / 2
    return max(0, T_promedio - Tbase)

def gompertz(GDD_acumulado, A, b, k):
    """RF3 y RF4. Modelo de crecimiento Gompertz."""
    if GDD_acumulado < 1: return 0.0
    return A * np.exp(-b * np.exp(-k * GDD_acumulado))

def asignar_BBCH(GDD_acumulado):
    """RF2. Asigna un estadio fenol√≥gico BBCH basado en GDD acumulado."""
    for (min_gdd, max_gdd), estadio in RANGOS_BBCH.items():
        if min_gdd <= GDD_acumulado <= max_gdd:
            return estadio
    if GDD_acumulado > max(max_gdd for _, max_gdd in RANGOS_BBCH.keys()):
        return "90 - Cosecha"
    return "00 - Germinaci√≥n"

def calcular_factor_estres_agua(humedad, CC, PMP):
    """Factor de Estr√©s H√≠drico (Fw) - Parte de RF7."""
    agua_disponible = humedad - PMP
    capacidad_maxima = CC - PMP
    if capacidad_maxima <= 0: return 1.0
    if agua_disponible <= 0: return 0.0 
    factor = agua_disponible / capacidad_maxima
    return min(1.0, factor) 

def calcular_factor_estres_temperatura(Tmax, Tmin, T_opt_min, T_opt_max):
    """Factor de Estr√©s T√©rmico (Ft) - Parte de RF7."""
    T_promedio = (Tmax + Tmin) / 2
    if T_opt_min <= T_promedio <= T_opt_max: return 1.0
    
    # Penalizaci√≥n simplificada
    if T_promedio < T_opt_min: return max(0.0, (T_promedio - 0) / (T_opt_min - 0))
    if T_promedio > T_opt_max: 
        T_letal = T_opt_max + 5
        return max(0.0, 1.0 - (T_promedio - T_opt_max) / (T_letal - T_opt_max))
    return 1.0 

def calcular_ET_Kc(ET0, Kc, Fw):
    """RF6. Evapotranspiraci√≥n Real (ETR) usando ET0, Kc y Factor de Estr√©s."""
    ET_potencial = ET0 * Kc 
    ET_real = ET_potencial * Fw 
    return max(0.0, ET_real)


# ==============================================================================
# 3. CLASE DE ESTADO DE LA PLANTA (RF7)
# ==============================================================================

class Planta:
    """Clase que mantiene el estado actual de la planta y el suelo (RF7)."""
    def __init__(self, config):
        self.Tbase = config['T_BASE']
        # K_EXTINCION no est√° en config, usando valor por defecto para evitar error
        self.k_extincion = 0.6 
        self.kc_bbch = config['KC_BBCH']
        self.param_estructural = config['GOMPERTZ_ESTRUCTURAL']
        self.param_foliar = config['GOMPERTZ_FOLIAR']
        self.T_opt_min = config['T_OPT_MIN']
        self.T_opt_max = config['T_OPT_MAX']
        self.escorrentia_fraccion = config['ESCORRENTIA_FRACCION']

        # Balance H√≠drico
        self.CC = config['SUELO_CC']
        self.PMP = config['SUELO_PMP']
        self.humedad_suelo = config['SUELO_INICIAL']
        
        # Variables de estado y seguimiento
        self.dia = 0
        self.GDD_acumulado = 0.0
        self.altura = 0.0
        self.LAI = 0.0
        self.BBCH = '00'
        
        self.factor_estres_total = 1.0
        self.ET_diaria_real = 0.0 
        self.perdida_drenaje = 0.0
        self.perdida_escorrentia = 0.0

    def actualizar_balance_agua(self, lluvia_diaria, riego_diario, ET_real):
        """RF6 MEJORADO. Actualiza Balance H√≠drico con Lluvia, Riego, Escorrent√≠a y Drenaje."""
        
        # 1. Entrada de Agua y P√©rdida por Escorrent√≠a (RF9)
        agua_total_entrada = lluvia_diaria + riego_diario
        agua_neta_infiltrada = agua_total_entrada * (1 - self.escorrentia_fraccion)
        self.perdida_escorrentia = agua_total_entrada * self.escorrentia_fraccion
        
        # 2. Balance h√≠drico provisional
        humedad_provisional = self.humedad_suelo + agua_neta_infiltrada - ET_real
        
        # 3. Drenaje Profundo (P√©rdida por debajo de Capacidad de Campo)
        self.perdida_drenaje = 0.0
        if humedad_provisional > self.CC:
            self.perdida_drenaje = humedad_provisional - self.CC
            self.humedad_suelo = self.CC # El exceso de agua se drena inmediatamente
        else:
            self.humedad_suelo = humedad_provisional

        # 4. Asegurar PMP
        self.humedad_suelo = max(self.PMP, self.humedad_suelo) 
        # Si la humedad cae a PMP, el factor de estr√©s Fw es 0, penalizando la ET y crecimiento.

    def actualizar_crecimiento_diario(self, GDD_diario, dia_data):
        """RF7. Ejecuta la secuencia diaria."""
        self.dia += 1
        self.GDD_acumulado += GDD_diario 
        
        # 1. C√°lculo de Estr√©s (Fw y Ft)
        Tmax, Tmin = dia_data['Tmax'], dia_data['Tmin']
        ET0 = dia_data['ET0']
        
        factor_estres_agua = calcular_factor_estres_agua(self.humedad_suelo, self.CC, self.PMP)
        factor_estres_temperatura = calcular_factor_estres_temperatura(
            Tmax, Tmin, self.T_opt_min, self.T_opt_max)
        
        # Factor de Estr√©s Total (RF7: el m√°s limitante)
        self.factor_estres_total = min(factor_estres_agua, factor_estres_temperatura)

        # 2. Asignaci√≥n BBCH (RF2) y Kc (RF6)
        self.BBCH = asignar_BBCH(self.GDD_acumulado)
        Kc = self.kc_bbch.get(self.BBCH.split(' ')[0], 0.5)

        # 3. C√°lculo de ET (RF6) y Actualizaci√≥n del Balance H√≠drico
        self.ET_diaria_real = calcular_ET_Kc(ET0, Kc, factor_estres_agua)
        self.actualizar_balance_agua(dia_data['Lluvia'], dia_data['Riego'], self.ET_diaria_real)

        # 4. Crecimiento (RF3 y RF4) - Modulado por F_Total
        
        # Altura (RF3)
        p_est = self.param_estructural
        altura_potencial = gompertz(self.GDD_acumulado, p_est['A'], p_est['b'], p_est['k'])
        delta_altura_potencial = altura_potencial - self.altura
        self.altura = self.altura + delta_altura_potencial * self.factor_estres_total
        self.altura = max(0.0, self.altura)

        # LAI (RF4)
        p_fol = self.param_foliar
        lai_potencial = gompertz(self.GDD_acumulado, p_fol['A'], p_fol['b'], p_fol['k'])
        delta_lai_potencial = lai_potencial - self.LAI
        self.LAI = self.LAI + delta_lai_potencial * self.factor_estres_total
        self.LAI = max(0.0, self.LAI)

        # 5. Intercepci√≥n de Luz (RF5)
        self.luz_interceptada = 1 - np.exp(-self.k_extincion * self.LAI)

        return {
            'D√≠a': self.dia,
            'GDD_Acumulado': self.GDD_acumulado,
            'Altura (cm)': round(self.altura, 2),
            'LAI (m2/m2)': round(self.LAI, 2),
            'F_Total': round(self.factor_estres_total, 2),
            'BBCH': self.BBCH
        }

# ==============================================================================
# 4. FUNCI√ìN PRINCIPAL DE SIMULACI√ìN INTERACTIVA (RF7, RF8, RF10)
# ==============================================================================

def ejecutar_simulacion():
    """RF7. Ejecuta el bucle de simulaci√≥n de forma interactiva."""
    print("--- üåø Iniciando Simulador de Cultivo V8 (Mensajes de Validaci√≥n Limpios) ---")
    
    # INTERACCI√ìN 1: Configuraci√≥n Inicial (RF9)
    config = solicitar_parametros_iniciales() 
    
    datos_met = generar_datos_met(config['DIAS_SIMULACION']) 
    mi_planta = Planta(config)

    resultados = [] 
    comando = 'S'

    for index, dia_data in datos_met.iterrows():
        GDD_diario = calcular_GDD_diario(dia_data['Tmax'], dia_data['Tmin'], mi_planta.Tbase)
        registro_diario = mi_planta.actualizar_crecimiento_diario(GDD_diario, dia_data)
        
        registro_completo = {**registro_diario,
                             'Lluvia (mm)': round(dia_data['Lluvia'], 2),
                             'Riego (mm)': round(dia_data['Riego'], 2),
                             'Perdida_Escorrentia (mm)': round(mi_planta.perdida_escorrentia, 2),
                             'Perdida_Drenaje (mm)': round(mi_planta.perdida_drenaje, 2),
                             'Humedad_Suelo (mm)': round(mi_planta.humedad_suelo, 2),
                             'ET_Real (mm)': round(mi_planta.ET_diaria_real, 2)}
        resultados.append(registro_completo)

        # INTERACCI√ìN 2: Control Paso a Paso (RF7)
        if comando != 'A':
            print(f"\n--- D√çA {mi_planta.dia} | BBCH: {mi_planta.BBCH} (GDD: {round(mi_planta.GDD_acumulado)}) ---")
            print(f"  > Altura: {registro_completo['Altura (cm)']} cm | LAI: {registro_completo['LAI (m2/m2)']}")
            print(f"  > Entrada (Lluvia+Riego): {registro_completo['Lluvia (mm)']+registro_completo['Riego (mm)']} mm | Salida (ET+Drenaje+Esc.): {registro_completo['ET_Real (mm)']+registro_completo['Perdida_Drenaje (mm)']+registro_completo['Perdida_Escorrentia (mm)']} mm")
            print(f"  > F_TOTAL: {registro_completo['F_Total']} | Humedad Final: {registro_completo['Humedad_Suelo (mm)']} mm")
            
            comando = input("Presione 'S' (Siguiente d√≠a), 'A' (Autom√°tico), 'F' (Finalizar): ").upper()
            
            if comando == 'F': break
            elif comando == 'A': print("Iniciando simulaci√≥n autom√°tica...")
            elif comando != 'S': comando = 'S'
    
    # Simulaci√≥n autom√°tica si el usuario eligi√≥ 'A'
    if comando == 'A':
        for index in range(mi_planta.dia, config['DIAS_SIMULACION']):
            dia_data = datos_met.iloc[index]
            GDD_diario = calcular_GDD_diario(dia_data['Tmax'], dia_data['Tmin'], mi_planta.Tbase)
            registro_diario = mi_planta.actualizar_crecimiento_diario(GDD_diario, dia_data)
            
            registro_completo = {**registro_diario,
                             'Lluvia (mm)': round(dia_data['Lluvia'], 2),
                             'Riego (mm)': round(dia_data['Riego'], 2),
                             'Perdida_Escorrentia (mm)': round(mi_planta.perdida_escorrentia, 2),
                             'Perdida_Drenaje (mm)': round(mi_planta.perdida_drenaje, 2),
                             'Humedad_Suelo (mm)': round(mi_planta.humedad_suelo, 2),
                             'ET_Real (mm)': round(mi_planta.ET_diaria_real, 2)}
            resultados.append(registro_completo)


    # 4. Procesar y Exportar Resultados (RF10)
    df_resultados = pd.DataFrame(resultados)
    nombre_archivo = 'simulacion_v8_validada_final.csv'
    df_resultados.to_csv(nombre_archivo, index=False)
    print(f"\nResultados exportados a: {nombre_archivo} (RF10)")
    
    # 5. Visualizaci√≥n (RF8)
    visualizar_resultados(df_resultados)


def visualizar_resultados(df):
    """RF8. Muestra gr√°ficos de las variables de crecimiento y estr√©s."""
    plt.style.use('seaborn-v0_8-whitegrid')
    # Usar los valores por defecto del config para la visualizaci√≥n
    local_default_config = {
        'SUELO_CC': 150.0,
        'SUELO_PMP': 50.0,
    }

    fig, axs = plt.subplots(2, 1, figsize=(12, 10))
    fig.suptitle('RF8: Visualizaci√≥n del Balance H√≠drico y Crecimiento (V8)', fontsize=16)

    # Gr√°fico 1: Balance H√≠drico (RF6) - El coraz√≥n de la nueva fidelidad
    axs[0].plot(df['D√≠a'], df['Humedad_Suelo (mm)'], label='Humedad Suelo Final (mm)', color='blue', linewidth=2)
    axs[0].axhline(y=local_default_config['SUELO_CC'], color='green', linestyle='--', alpha=0.6, label='Capacidad Campo (CC)')
    axs[0].axhline(y=local_default_config['SUELO_PMP'], color='red', linestyle='--', alpha=0.6, label='Punto Marchitez (PMP)')
    
    # Entradas/Salidas
    axs[0].fill_between(df['D√≠a'], 0, df['Lluvia (mm)'], alpha=0.3, color='skyblue', label='Lluvia (mm)')
    axs[0].bar(df['D√≠a'], df['Riego (mm)'], label='Riego (mm)', color='darkcyan', alpha=0.6, width=1.0) 
    
    ax2 = axs[0].twinx()
    ax2.plot(df['D√≠a'], df['ET_Real (mm)'], label='ET Real (mm)', color='darkorange', linestyle='-')
    ax2.plot(df['D√≠a'], df['Perdida_Drenaje (mm)'], label='P√©rdida Drenaje (mm)', color='purple', linestyle=':')
    ax2.set_ylabel('Flujos de Agua (mm/d√≠a)')
    ax2.tick_params(axis='y')
    
    axs[0].set_ylabel('Humedad Suelo (mm)')
    axs[0].set_title('Balance H√≠drico Detallado: Lluvia, Riego, Escorrent√≠a y Drenaje (RF6)')
    axs[0].legend(loc='upper left')
    ax2.legend(loc='upper right')
    

    # Gr√°fico 2: Crecimiento y Estr√©s Dual (RF3, RF4, RF7)
    axs[1].plot(df['D√≠a'], df['Altura (cm)'], label='Altura (cm) - RF3', color='green')
    axs[1].plot(df['D√≠a'], df['LAI (m2/m2)'], label='LAI (m2/m2) - RF4', color='saddlebrown')
    
    ax3 = axs[1].twinx()
    ax3.plot(df['D√≠a'], df['F_Total'], label='Factor Estr√©s Total ($F_{Total}$)', color='red', linestyle='-')
    ax3.set_ylabel('Factor Estr√©s (0.0-1.0)', color='red')
    ax3.tick_params(axis='y', labelcolor='red')
    
    axs[1].set_xlabel('D√≠a de Simulaci√≥n')
    axs[1].set_ylabel('Altura / LAI')
    axs[1].set_title('Crecimiento Modulado por el Factor de Estr√©s Total (RF7)')
    axs[1].legend(loc='upper left')
    ax3.legend(loc='upper right')

    plt.tight_layout()
    plt.show()

# Ejecuci√≥n del programa
if __name__ == "__main__":
    ejecutar_simulacion()
